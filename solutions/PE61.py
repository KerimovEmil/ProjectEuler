"""
PROBLEM

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers
and are generated by the following formulae:

Triangle	 	P3,n = n(n+1)/2	 	    1, 3, 6, 10, 15, ...
Square	 	    P4,n = n^2	        	1, 4, 9, 16, 25, ...
Pentagonal	 	P5,n = n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P6,n = n(2n−1)	 	    1, 6, 15, 28, 45, ...
Heptagonal	 	P7,n = n(5n−3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P8,n = n(3n−2)	 	    1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

1) The set is cyclic, in that the last two digits of each number is the first two digits of the next number
   (including the last number with the first).

2) Each polygonal type: triangle (P3,127 = 8128), square (P4,91 = 8281), and pentagonal (P5,44 = 2882), is represented
   by a different number in the set.

3) This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle,
square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

ANSWER: 28684
Solve time: ~0.03 seconds
"""

from util.utils import timeit
import unittest
from typing import List, Tuple, Set, Dict


def polygonal(figurate=3, digits=4):
    """
    yields all the polygonal numbers whose number of digits is equal to the limit
    figurate examples:
     3=Triangle	 	    n(n+1)/2	 	1, 3, 6, 10, 15, ...
     4=Square	 	    n^2	        	1, 4, 9, 16, 25, ...
     5=Pentagonal	 	n(3n−1)/2	 	1, 5, 12, 22, 35, ...
     6=Hexagonal	 	n(2n−1)	 	    1, 6, 15, 28, 45, ...
     7=Heptagonal	 	n(5n−3)/2	 	1, 7, 18, 34, 55, ...
     8=Octagonal	 	n(3n−2)	 	    1, 8, 21, 40, 65, ...
    """
    dc_poly = {
        3: lambda x: x*(x+1)//2,
        4: lambda x: x**2,
        5: lambda x: x*(3*x-1)//2,
        6: lambda x: x*(2*x-1),
        7: lambda x: x*(5*x-3)//2,
        8: lambda x: x*(3*x-2),
    }
    f = dc_poly[figurate]
    s, n = 1, 1
    while s < 10**digits:
        if s >= 10**(digits - 1):
            yield s
        s = f(n)
        n += 1


class Problem61:
    def __init__(self, digits):
        self.digits = digits
        self.dc_cycle_pairs = dict()

    @staticmethod
    def compare(n1: int, n2: int) -> bool:
        """See if n2 can come after n1 in the cycle"""
        return n1 % 100 == n2 // 100

    def traverse(self, num_pair: Tuple[int, int], num_cycle: List[int], figurate_cycle: List[int], max_len: int):

        # return condition
        if len(num_cycle) == max_len and self.compare(num_cycle[-1], num_cycle[0]):
            return num_cycle

        # loop through next numbers
        for n, f in self.dc_cycle_pairs.get(num_pair, []):
            if f not in figurate_cycle and n not in num_cycle:
                output = self.traverse(num_pair=(n, f), num_cycle=num_cycle + [n], figurate_cycle=figurate_cycle + [f],
                                       max_len=max_len)
                if output:
                    return output

    def get_all_numbers(self, max_figurate: int) -> Set[Tuple[int, int]]:
        """Return a set of tuples for all possible numbers to consider in the cycles"""
        return set((n, f) for f in range(3, max_figurate + 1) for n in polygonal(figurate=f, digits=self.digits))

    def get_dict_cycles(self, all_numbers: Set[Tuple[int, int]]) -> Dict[Tuple[int, int], List[Tuple[int, int]]]:
        """Create a dictionary of all numbers which can follow the key number"""
        dc_cycle_pairs = {}
        for n1, f1 in all_numbers:
            for n2, f2 in all_numbers:
                if f1 != f2 and self.compare(n1, n2):
                    dc_cycle_pairs[(n1, f1)] = dc_cycle_pairs.get((n1, f1), []) + [(n2, f2)]
        return dc_cycle_pairs

    @timeit
    def solve(self, max_figurate):
        all_numbers = self.get_all_numbers(max_figurate=max_figurate)
        self.dc_cycle_pairs = self.get_dict_cycles(all_numbers=all_numbers)

        for num_pair in self.dc_cycle_pairs.keys():
            output_cycle = self.traverse(num_pair, num_cycle=[num_pair[0]], figurate_cycle=[num_pair[1]],
                                         max_len=max_figurate - 2)
            if output_cycle:
                return sum(output_cycle)


class Solution61(unittest.TestCase):
    def setUp(self):
        self.problem = Problem61(digits=4)

    def test_example_solution(self):
        self.assertEqual(19291, self.problem.solve(max_figurate=5))

    def test_solution(self):
        # [1281, 8128, 2882, 8256, 5625, 2512] -> 28684
        self.assertEqual(28684, self.problem.solve(max_figurate=8))


if __name__ == '__main__':
    unittest.main()
