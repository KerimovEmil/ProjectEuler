# Problem 101

# If we are presented with the first k terms of a sequence it is impossible to say with certainty the value
# of the next term, as there are infinitely many polynomial functions that can model the sequence.
#
# As an example, let us consider the sequence of cube numbers. This is defined by the generating function,
# u_n = n^3: 1, 8, 27, 64, 125, 216, ...
#
# Suppose we were only given the first two terms of this sequence. Working on the principle that "simple is best"
# we should assume a linear relationship and predict the next term to be 15 (common difference 7). Even if we were
# presented with the first three terms, by the same principle of simplicity, a quadratic relationship should be assumed.
#
# We shall define OP(k, n) to be the nth term of the optimum polynomial generating function for the first k terms of
# a sequence. It should be clear that OP(k, n) will accurately generate the terms of the sequence for n ≤ k, and
# potentially the first incorrect term (FIT) will be OP(k, k+1); in which case we shall call it a bad OP (BOP).
#
# As a basis, if we were only given the first term of sequence, it would be most sensible to assume constancy;
# that is, for n ≥ 2, OP(1, n) = u1.
#
# Hence we obtain the following OPs for the cubic sequence:
#
# OP(1, n) = 1      	 1, <1>, 1, 1, ...
# OP(2, n) = 7n−6	     1, 8, <15>, ...
# OP(3, n) = 6n^2−11n+6  1, 8, 27, <58>, ...
# OP(4, n) = n^3	     1, 8, 27, 64, 125, ...
# Clearly no BOPs exist for k ≥ 4.
#
# By considering the sum of FITs generated by the BOPs (indicated in <> above), we obtain 1 + 15 + 58 = 74.
#
# Consider the following tenth degree polynomial generating function:
#
# u_n = 1 − n + n^2 − n^3 + n^4 − n^5 + n^6 − n^7 + n^8 − n^9 + n^10
#
# Find the sum of FITs for the BOPs.

# ANSWER
# 37076114526

import numpy as np
from util.utils import timeit


class Problem101:
    def __init__(self, max_power):
        self.max_power = max_power
        self.ans = 0

    def generating_poly(self, n):
        return (1 + n ** (self.max_power + 1)) / (1 + n)

    @timeit
    def solve(self):
        for k in range(1, self.max_power + 1):
            ls_coef = np.polyfit(y=[self.generating_poly(i) for i in range(1, k+1)], x=range(1, k+1), deg=k-1)
            self.ans += int(np.poly1d(ls_coef)(k+1) + 0.5)

        return self.ans

    def get_solution(self):
        return self.ans


if __name__ == "__main__":
    obj = Problem101(max_power=10)
    sol = obj.solve()
    print(sol)
